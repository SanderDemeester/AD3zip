\documentclass[10pt,a4paper]{report}
\setlength\parindent{0pt}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{fullpage}

\author{Sander Demeester}
\title{Data compression - Burrows-Wheeler}
\begin{document}
\maketitle
\begin{abstract}
In dit verslag leg ik kort uit welke algoritmes ik heb ge\"implementeerd en op welke manier ik dit heb gedaan, ik zal ook kort toelichten hoe mijn code is gestructureerde en welke ontwikkelings beslissingen ik heb genomen en waarom.\\

Daarna wat het effect is van de verschillende algoritmes op voorbeeld test bestanden en tijdsmetingen van verschillende implementaties van die algoritmen. 
\end{abstract}
\section*{Beschrijving implementatie}
\subsection*{main.c}
Om de verschillende implementaties op een elegante manier te laten uitvoeren adhv een parameter die wordt meegeggeven heb ik gebruik gemaakt van functie pointers die in een struct (compressie\_argument) zitten samen met een value. Deze value wordt mee in de header geschreven om daarna te worden ingelezen door het decoderen in de variabel compressie\_function\_pointer, een simpele for-lus zal daarna het correct algoritme uitvoeren op basis van die variabel.\\

De file wordt hier ingelezen en verdeeld in blokken van grote $\text{blocksize}*1024$ om daarna in seqentie te worden verwerkt door het gespecificeerde algoritme, de stub voor al deze algoritmes bevind zich in de source-file "compressie\_methode.c".
\subsection*{compressie\_methode.c}
Deze source file bevat de stub voor het encoderen en decoderen van de verschilende algoritmes, het werk wordt via de struct compressie\_argument gedelegeert naar hier. Algoritme 1 is standaard huffman met move to front toegepaste op een Burrows-Wheeler vector, Burrows-Wheeler wordt altijd eerst uitgevoerdt in main.c, testen hebben aangeduid dat dit bijna altijd een optimalere tekst maakt lostaand van welk algoritme we dan ook gebruiken om onze tekst mee te encoderen. Er wordt een parameter meegegeven aan deze functie die zeggen of ze de input buffer moeten zien als en blok en enkel deze blokken moeten encoderen, of ze zelf de gegeven input buffer nog moeten in blokken segmenteren en elk van deze blokken moeten gaan decoderen. Het doorgeven en terug geven van resulaten van deze stub code naar de correcte functies gebeurdt voor het encoderen van die zelfde buffer, wanneer de buffer wordt gealloceerd wordt er rekening meegehouden dat de lengte van het resultaat in de eerste 4bytes zal staan van de buffer. \\

Voor het terug geven van het resultaat bij het decoderen is er een speciale struct voorzien, nl ("huffman\_decode\_result") en ("lz77\_result"). 
\subsection*{bw.c}
Elke implementatie van een algoritme heeft de mogelijkheid individueel te worden getest, dit is om eenvoudiger bugs op te sporen en indivuduele tijdsmeetingen te doen, via algoritme parameter "0" is het mogelijk om enkel Burrows-Wheeler toe te passen op een tekst.\\

Burrows-Wheeler is een manier om gegeven een tekst $t$ deze om te zetten naar een tekst $t^{'}$ waar $t^{'}$ beter is gestructureerd voor compressie met bv, huffman. Dit wordt gedaan door de tekst te zien als een matrix $M$ en deze lexografish te sorteren en de laaste kolom te zien als onze Burrows-Wheeler vector. Deze vector bevat als componenten de prefixen voor de eerste kolom vector van de matrix $M$. We merken op dat het optimaal zou zijn om de eerste kolom als Burrows-Wheeler vector te gebruiken, helaas is het niet mogelijk om enkel uit deze vector de originele tekst terug te constru\"en. Dit is wel mogelijk al we de laaste kolom van $M$ gebruiken (omdat $M$ een cyclische permutatie is). Het is belangrijk om in te zien dat de laaste kolom gebruiken dan wel niet de meest optimale manier is, het is nog altijd een prima transformatie! Hierbij is het belangrijk om te zien wat Burrows-Wheeler doet en op welke input teksten het een positief effect heeft. \\

We onderscheiden 2 soorten teksten. De eerste tekst is een random tekst, eventueel gemaakt met /dev/urandom, of de output van een goed encryptie cijfer, zoals AES. De tweede tekst is een tekst uit de nederlandse taal. \\
Voor de eerste tekst geldt dat er geen verbanden zijn tussen de opeenvolgende bytes in de tekst. Dus wanneer we een lexografish orderning opleggen zal deze geen zinnevolle invloed hebben op de compresibiliteit van de tekst (nl, het aantal herhalingen van dezelfde bytes na elkaar). We hebben het hier niet over de compresibiliteit van de eerste kolom! Want deze zou dezelfde zijn voor een random tekst als voor een taalkundig gestructureede tekst, maar wel over de prefixen van de symbolen in de eerste kolom, nl de laatste kolom van $M$.

Als we dit vergelijken met de 2de soort tekst dan merken we wel op dat er een verband is tussen opeenvolgende bytes, bepaalde opeenvolging van bytes komen herhaaldelijk voor in een gegeven tekst. Als we nu hier een lexografish orderning opleggen zullen we zien de eerste kolom van $M$ terug alle suffixen bevat als van laatste kolom, het verschil is nu dat de componenten in de laatste kolom nu ook een prima compresibiliteit heeft omdat er een taalkundig verband is tussen de opeenvolgende bytes.

Om enkel de snelheid van Burrow-Wheeler te testen heb ik 20 random files aangemaakt met grote 1MiB tem 20Mib en deze laten encoderen met varierende blokgrotes, 1 tem 5KiB\\

De functie die de Burrows-Wheeler implementatie opstelt neemt als argument een \emph{bwt\_blok} van lente \emph{len} en maakt een array van lengte \emph{len} die als waarde de indexen heeft van \emph{bwt\_blok}, daarna zullen we \emph{bwt\_blok} kopieren naar \emph{bwt\_transformatie} omdat we de originele tekst zullen overschrijven met onze Burrows-Wheeler vector. We zullen de lijst met indexen beschouwen als een lijst van pointers in de \emph{bwt\_transformatie}. Deze ene lijst zullen we samen met de gebruiken als voorstelling van onze Burrows-Wheeler matrix. De manier waarop ik dit heb gedaan kan worden gezien aan het volgend stukje c-code die eenvoudig deze matrix uitprint:

\begin{lstlisting}
int i = 0;
  int j = 0;
  for(i=0; i < len; i++){
    for(j = 0; j < len; j++){
      printf("%c",*(&rij[(rij_index[i]+j) % len]));
    }
    printf("\n");
  }
\end{lstlisting}
Waar dus $(i,j)$ resp rij en kolom voorstellen en de elementen uit \emph{rij\_index} gebruiken als pointers in de rij die onze Burrows-Wheeler transformatie moet voorstellen. \\

Daarna zal een aangepaste versie van het quicksort sorteer algoritme worden gebruikt om de rij van indexen te sorteren adhv de waarden in de rij \emph{bwt\_transformatie}.\\

Het quicksort algoritme is lichtjes aangepast om correct te kunnen werken met de voorstelling van de Burrows-Wheeler transformatie, nl als er gelijke elementen zijn moeten kijken naar het volgende element in de huidige rij van deze matrix, dit is enkel maar bij het encoderen want bij het decoderen passen we een andere manier van elementen vergelijken toe. Er wordt gebruikt gemaakt van de volgende c-notatie om dit correct te laten gebeuren. 
\begin{lstlisting}
 while(*(&rij[(rij_index[links]+offset)%len]) == *(&rij[(rij_index[begin]+offset)%len])){
	    if(offset+1 == len){	  
	      break;
	    } 
	    offset = (offset+1) % len;
	  }
	  
	  if(*(&rij[(rij_index[links]+offset) % len]) > *(&rij[(rij_index[begin]+offset) % len])){
	    swap(&(rij_index[links]),&(rij_index[--rechts]));
	  }else{
	    links++;	  
	  }
\end{lstlisting}
We houden een offset bij en maken terug gebruik van de modulo operator om naar het correct element te gaan dat wordt aangeduid door de pointer in \emph{rij\_index} waarop we dan de offset bijtellen om te kijken of deze volgende tekens duidelijk van elkaar verschillen.\\

Daarna gaan we met een simpele for-lus de laatste kolom nemen uit deze matrix en dit zal onze finale Burrows-Wheeler transformatie zijn. De laaste kolom uit een cyclische gepermuteerde matrix die door 1 rij wordt voorgestelt halen we op met de volende c-notatie:
\begin{lstlisting}
bwt_blok[i]= *(&bwt_transformatie[(rij_index[i-5]+(blocksize-1)) % blocksize]);
\end{lstlisting}
Voor het decoderen van een Burrows-Wheeler transformatie zijn de eerste 4 bytes de startpositie van onze vector, daarna maken we 2 rijen aan, \emph{sorted\_rij\_index} en \emph{bwt\_rij\_index}. De \emph{sorterd\_rij\_index} zal de lijst zijn die wordt gesorteerdt door quicksort op basis van de Burrows-Wheeler vector. De andere rij, \emph{bwt\_rij\_index} zal gewoon een lijst zijn met pointers naar de niet gesorteerde originele Burrows-Wheeler vector. \\

Nu maken we gebruik van het feit dat de Burrows-Wheeler matrix een cyclische permutatie is van een reeks tekst, en aangezien we als vector de laatste kolom van deze matrix hebben gebruikt weten we ook dat de eerste kolom van deze marix de prefix is voor de Burrows-Wheeler vector, nu omdat we een cyclische permutatie hebben weten dat het volgende element staat op de index in de originele lijst van niet gesorteerde lijst met pointers, waardoor het vinden van de volgende positie triviaal simpel wordt en de implementatie kan gewoon worden bekomen door simpele for-lus over de lengte van de vector.
\begin{lstlisting}
for(int i = 0; i < len; i++){
	start_pos = sorted_rij_index[bwt_rij_index[start_pos]];
}
\end{lstlisting}
Wat de volledige complexiteit voor het decoderen $O(2n + \log n)$ maakt.
\section*{move\_to\_front.c}
Met de \emph{Move to front}-methode proberen we het idee dat we proberen te bereiken met Burrows-Wheeler (nl, vaak voorkomende tekens samen te groeperen en lieft met zoon klein mogelijk index nummer). Move to front dit exact dit, het gaat gegeven een input string en een alfabet alle symbolen in de input string overlopen en de index van het huidige symbool opslaan en vooraan plaatsen in het alfabet. Dit zal tot gevolg hebben dat symbolen die vaak voorkomen in de input string zullen resulteren in een laag index positie nummer in het resultaat omdat deze tekens vaak vooraan blijven zitten in het alfabet.\\


\end{document}