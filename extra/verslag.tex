\documentclass[10pt,a4paper]{report}
\setlength\parindent{0pt}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{fullpage}

\author{Sander Demeester}
\title{Data compression - Burrows-Wheeler}
\begin{document}
\maketitle
\begin{abstract}
In dit verslag leg ik kort uit welke algoritmes ik heb ge\"implementeerd en op welke manier ik dit heb gedaan, ik zal ook kort toelichten hoe mijn code is gestructureerde en welke ontwikkelings beslissingen ik heb genomen en waarom.\\

Daarna wat het effect is van de verschillende algoritmes op voorbeeld test bestanden en tijdsmetingen van verschillende implementaties van die algoritmen. 
\end{abstract}
\section*{Beschrijving implementatie}
\subsection*{main.c}
Om de verschillende implementaties op een elegante manier te laten uitvoeren adhv een parameter die wordt meegeggeven heb ik gebruik gemaakt van functie pointers die in een struct (compressie\_argument) zitten samen met een value. Deze value wordt mee in de header geschreven om daarna te worden ingelezen door het decoderen in de variabel compressie\_function\_pointer, een simpele for-lus zal daarna het correct algoritme uitvoeren op basis van die variabel.\\

De file wordt hier ingelezen en verdeeld in blokken van grote $\text{blocksize}*1024$ om daarna in seqentie te worden verwerkt door het gespecificeerde algoritme, de stub voor al deze algoritmes bevind zich in de source-file "compressie\_methode.c".
\subsection*{compressie\_methode.c}
Deze source file bevat de stub voor het encoderen en decoderen van de verschilende algoritmes, het werk wordt via de struct compressie\_argument gedelegeert naar hier. Algoritme 1 is standaard huffman met move to front toegepaste op een Burrows-Wheeler vector, Burrows-Wheeler wordt altijd eerst uitgevoerdt in main.c, testen hebben aangeduid dat dit bijna altijd een optimalere tekst maakt lostaand van welk algoritme we dan ook gebruiken om onze tekst mee te encoderen. Er wordt een parameter meegegeven aan deze functie die zeggen of ze de input buffer moeten zien als en blok en enkel deze blokken moeten encoderen, of ze zelf de gegeven input buffer nog moeten in blokken segmenteren en elk van deze blokken moeten gaan decoderen. Het doorgeven en terug geven van resulaten van deze stub code naar de correcte functies gebeurdt voor het encoderen van die zelfde buffer, wanneer de buffer wordt gealloceerd wordt er rekening meegehouden dat de lengte van het resultaat in de eerste 4bytes zal staan van de buffer. \\

Voor het terug geven van het resultaat bij het decoderen is er een speciale struct voorzien, nl ("huffman\_decode\_result") en ("lz77\_result"). 
\subsection*{bw.c}
Elke implementatie van een algoritme heeft de mogelijkheid individueel te worden getest, dit is om eenvoudiger bugs op te sporen en indivuduele tijdsmeetingen te doen, via algoritme parameter "0" is het mogelijk om enkel Burrows-Wheeler toe te passen op een tekst.\\

Burrows-Wheeler is een manier om gegeven een tekst $t$ deze om te zetten naar een tekst $t^{'}$ waar $t^{'}$ beter is gestructureerd voor compressie met bv, huffman. Dit wordt gedaan door de tekst te zien als een matrix $M$ en deze lexografish te sorteren en de laaste kolom te zien als onze Burrows-Wheeler vector. Deze vector bevat als componenten de prefixen voor de eerste kolom vector van de matrix $M$. We merken op dat het optimaal zou zijn om de eerste kolom als Burrows-Wheeler vector te gebruiken, helaas is het niet mogelijk om enkel uit deze vector de originele tekst terug te constru\"en. Dit is wel mogelijk al we de laaste kolom van $M$ gebruiken (omdat $M$ een cyclische permutatie is). Het is belangrijk om in te zien dat de laaste kolom gebruiken dan wel niet de meest optimale manier is, het is nog altijd een prima transformatie! Hierbij is het belangrijk om te zien wat Burrows-Wheeler doet en op welke input teksten het een positief effect heeft. \\

We onderscheiden 2 soorten teksten. De eerste tekst is een random tekst, eventueel gemaakt met /dev/urandom, of de output van een goed encryptie cijfer, zoals AES. De tweede tekst is een tekst uit de nederlandse taal. \\
Voor de eerste tekst geldt dat er geen verbanden zijn tussen de opeenvolgende bytes in de tekst. Dus wanneer we een lexografish orderning opleggen zal deze geen zinnevolle invloed hebben op de compresibiliteit van de tekst (nl, het aantal herhalingen van dezelfde bytes na elkaar). We hebben het hier niet over de compresibiliteit van de eerste kolom! Want deze zou dezelfde zijn voor een random tekst als voor een taalkundig gestructureede tekst, maar wel over de prefixen van de symbolen in de eerste kolom, nl de laatste kolom van $M$.

Als we dit vergelijken met de 2de soort tekst dan merken we wel op dat er een verband is tussen opeenvolgende bytes, bepaalde opeenvolging van bytes komen herhaaldelijk voor in een gegeven tekst. Als we nu hier een lexografish orderning opleggen zullen we zien de eerste kolom van $M$ terug alle suffixen bevat als van laatste kolom, het verschil is nu dat de componenten in de laatste kolom nu ook een prima compresibiliteit heeft omdat er een taalkundig verband is tussen de opeenvolgende bytes.

Om enkel de snelheid van Burrow-Wheeler te testen heb ik 20 random files aangemaakt met grote 1MiB tem 20Mib en deze laten encoderen met varierende blokgrotes, 1 tem 5KiB\\

De functie die de Burrows-Wheeler implementatie opstelt neemt als argument een \emph{bwt\_blok} van lente \emph{len} en maakt een array van lengte \emph{len} die als waarde de indexen heeft van \emph{bwt\_blok}, daarna zullen we \emph{bwt\_blok} kopieren naar \emph{bwt\_transformatie} omdat we de originele tekst zullen overschrijven met onze Burrows-Wheeler vector. We zullen de lijst met indexen beschouwen als een lijst van pointers in de \emph{bwt\_transformatie}. Deze ene lijst zullen we samen met de gebruiken als voorstelling van onze Burrows-Wheeler matrix. De manier waarop ik dit heb gedaan kan worden gezien aan het volgend stukje c-code die eenvoudig deze matrix uitprint:

\begin{lstlisting}
int i = 0;
  int j = 0;
  for(i=0; i < len; i++){
    for(j = 0; j < len; j++){
      printf("%c",*(&rij[(rij_index[i]+j) % len]));
    }
    printf("\n");
  }
\end{lstlisting}
Waar dus $(i,j)$ resp rij en kolom voorstellen en de elementen uit \emph{rij\_index} gebruiken als pointers in de rij die onze Burrows-Wheeler transformatie moet voorstellen. \\

Daarna zal een aangepaste versie van het quicksort sorteer algoritme worden gebruikt om de rij van indexen te sorteren adhv de waarden in de rij \emph{bwt\_transformatie}.\\

Het quicksort algoritme is lichtjes aangepast om correct te kunnen werken met de voorstelling van de Burrows-Wheeler transformatie, nl als er gelijke elementen zijn moeten kijken naar het volgende element in de huidige rij van deze matrix, dit is enkel maar bij het encoderen want bij het decoderen passen we een andere manier van elementen vergelijken toe. Er wordt gebruikt gemaakt van de volgende c-notatie om dit correct te laten gebeuren. 
\begin{lstlisting}
 while(*(&rij[(rij_index[links]+offset)%len]) == *(&rij[(rij_index[begin]+offset)%len])){
	    if(offset+1 == len){	  
	      break;
	    } 
	    offset = (offset+1) % len;
	  }
	  
	  if(*(&rij[(rij_index[links]+offset) % len]) > *(&rij[(rij_index[begin]+offset) % len])){
	    swap(&(rij_index[links]),&(rij_index[--rechts]));
	  }else{
	    links++;	  
	  }
\end{lstlisting}
We houden een offset bij en maken terug gebruik van de modulo operator om naar het correct element te gaan dat wordt aangeduid door de pointer in \emph{rij\_index} waarop we dan de offset bijtellen om te kijken of deze volgende tekens duidelijk van elkaar verschillen.\\

Daarna gaan we met een simpele for-lus de laatste kolom nemen uit deze matrix en dit zal onze finale Burrows-Wheeler transformatie zijn. De laaste kolom uit een cyclische gepermuteerde matrix die door 1 rij wordt voorgestelt halen we op met de volende c-notatie:
\begin{lstlisting}
bwt_blok[i]= *(&bwt_transformatie[(rij_index[i-5]+(blocksize-1)) % blocksize]);
\end{lstlisting}
Voor het decoderen van een Burrows-Wheeler transformatie zijn de eerste 4 bytes de startpositie van onze vector, daarna maken we 2 rijen aan, \emph{sorted\_rij\_index} en \emph{bwt\_rij\_index}. De \emph{sorterd\_rij\_index} zal de lijst zijn die wordt gesorteerdt door quicksort op basis van de Burrows-Wheeler vector. De andere rij, \emph{bwt\_rij\_index} zal gewoon een lijst zijn met pointers naar de niet gesorteerde originele Burrows-Wheeler vector. \\

Nu maken we gebruik van het feit dat de Burrows-Wheeler matrix een cyclische permutatie is van een reeks tekst, en aangezien we als vector de laatste kolom van deze matrix hebben gebruikt weten we ook dat de eerste kolom van deze marix de prefix is voor de Burrows-Wheeler vector, nu omdat we een cyclische permutatie hebben weten dat het volgende element staat op de index in de originele lijst van niet gesorteerde lijst met pointers, waardoor het vinden van de volgende positie triviaal simpel wordt en de implementatie kan gewoon worden bekomen door simpele for-lus over de lengte van de vector.
\begin{lstlisting}
for(int i = 0; i < len; i++){
	start_pos = sorted_rij_index[bwt_rij_index[start_pos]];
}
\end{lstlisting}
Wat de volledige complexiteit voor het decoderen $O(2n + \log n)$ maakt.
\subsection*{move\_to\_front.c}
Met de \emph{Move to front}-methode proberen we het idee dat we proberen te bereiken met Burrows-Wheeler (nl, vaak voorkomende tekens samen te groeperen en lieft met zoon klein mogelijk index nummer). Move to front dit exact dit, het gaat gegeven een input string en een alfabet alle symbolen in de input string overlopen en de index van het huidige symbool opslaan en vooraan plaatsen in het alfabet. Dit zal tot gevolg hebben dat symbolen die vaak voorkomen in de input string zullen resulteren in een laag index positie nummer in het resultaat omdat deze tekens vaak vooraan blijven zitten in het alfabet.\\

Voor mijn implementatie heb ik gebruikt gemaakt van een dubbele cyclische gelinked lijst die als waardes een unsigned byte bijhoudt en een pointer naar het volgende en vorige element. De volledige  gelinked lijst heeft standaard als waardes die kunnen worden voorgesteld door 1 byte, nl 256 waarden.\\ 
Een simpele for-lus overloopt alle waardes in de input string en maakt daarin gebruik van een while lus die door de gelinked lijst loopt tot dat de gezochte waarde is gevonden in de gelinked lijst, er wordt een teller bijgehouden die kijkt wat de positie is van het gezocht symbool in de gelinked lijst en die wegschrijft.\\

Voor simpliciteit beschouwen we 2 gevallen in deze linkedlist, als het eerste element vooraan staat moet niks gebeuren (dit is het geval als c==0), in het andere geval verhangen we het gevonden element naar de eerste plaats.\\

Ook voor deze code heb ik een aparte unit test file gemaakt om te kunnen garanderen dat deze code correct werkt. 
\subsection*{huffman.c}
Deze source file bevat alle code die betrekking heeft op mijn implementatie van het standaard huffman algoritme. Het encoderen en decoderen van het algoritme is  ge\"emplementeerd in de zelfde functie, adhv een paramter kan worden beslist wat er moet worden uitgevoerd. \\

\subsubsection*{Encoderen}
Eerst wordt een frequentietabel gebouwde van bytes in de input\_string. Daarna gaan we 256 codewoorden aanmaken (van het type huffman\_codewoord). Deze codewoorden worden geindexeerd met de ascii waarden van de originele byte (de byte die ze voorstellen) en bevatten 2 velden, het aantal bits dat deze code bevat en de code zelf. Ook worden huffman\_toppen aangemaakt, deze toppen stellen de originele bytes voor die een freqentie hebben groter dan 0. Deze lijst van toppen zal worden gebruikt om de huffman code op te stellen. \\

In de hulp functie \emph{build\_huffman\_code} zullen deze toppen in omgekeerd sorteeerde volgorde worden overlopen (van lage frequentie naar hoge frequentie). 
$$(t_{0},t_{1},\cdots,t_{n-1},t_{n}) | w(t_{i}) < w(t_{i-1})$$
met $w(t)$ het frequentie gewicht van top $t$. We beschouwen de 2 elementen met de laagste frequentie, dit zijn $(t_{n-1},t_{n})$, deze bevatten een lijst van value (de eerste keer dat dit wordt uitgevoerd bevat elke top maar 1 value, voor de volgende iteraties zullen deze toppen meer values bevatten) die we gaan gebruiken als indexen in onze code tabel waar we bits gaan shiften. Voor $t_{n-1}$ bit "1", resp voor $t_{n}$ bit "0". In c-notatie:
\begin{lstlisting}
for(k = 0; k  < huffman_toppen[i-1]->aantal_elementen; k++){       
	code[(uint32_t)huffman_toppen[i-1]->value[k]]->code <<= 1; 
	code[(uint32_t)huffman_toppen[i-1]->value[k]]->code |= (1<<0);
	code[(uint32_t)huffman_toppen[i-1]->value[k]]->number_of_bits++;
\end{lstlisting}

Eenmaal dit is gedaan zullen we de 2 laagste toppen samenvoegen tot 1
We werken nog altijd met $(t_{n-1},t_{n})$. Het veld \emph{aantal\_elementen} zal de som van beide vleden \emph{aantal\_elementen} zijn van de 2 toppen, het gewicht (de frequentie) zal ook samen worden getelt en originele bytes die de toppen voorstelde zullen ook worden samengevoegd. Daarna zal deze nieuwe top een opwaarste perculatie maken tot dat zijn frequentie waarde net kleiner is dan de top boven hem in de lijst.\\

Er wordt uiteraardt geen nieuwe top aangemaakt maar top $t_{n-1}$ wordt herbruikt, dit wordt herhaalt tot er nog 1 top over is. \\

Daarna wordt de originele tekst gebruikt als indexen naar de codes en worden code bits uit deze code geshift in een output buffer, de code is slim genoeg om te merken hoeveel plaats er nog vrij is de huidige output byte en kan codewoorden opdelen zodat het aantal output bytes optimaal kan worden benut.
Daarna wordt een huffman header opgestelt die uit 12byte bestaat.\\
De eerste 4bytes is de lengte van het volledige huffman blok, incl de huffmancode en huffman frequentie  (zonder de header). 
De volgende 4 bytes is de lengte van de huffman code zelf. De laatste 4 bytes is de lengte van de huffman frequentie.\\

Bij elk huffman blok wordt ook de huffman frequentie doorgegeven. Elke frequentie blok heeft een lengte van 5 bytes, 4 bytes om het aantal voorkomens mee aan te duiden en 1 byte om het originele teken zelf voor te stellen. Enkel de frequenties voor niet 0 bytes worden opgenomen in deze huffman frequentie. Ik maak geen gebruik van relatieve frequenties omdat er gevallen zijn waar afronding van floating point getallen zou kunnen leiden tot verkeerde frequenties endus tot verkeerde codes bij het decoderen.\\
\subsubsection*{Decoderen}
\end{document}